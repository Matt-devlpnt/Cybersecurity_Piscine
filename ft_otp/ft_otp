#!/usr/bin/env python3


##########
# Import #
##########

import os
import sys
import argparse
import base64
import json
import getpass
from cryptography.hazmat.primitives.kdf.argon2 import Argon2id
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding


####################
# Globale variable #
####################

FILE_KEY="ft_otp.key"


###########
# Program #
###########

def valid_key(key):

    try:
        file = open(key, 'rt')
        if file.readable():
            file_content = file.read()
            key = file_content
    except:
        pass

    if len(key) < 64:
        print("Please for -g arg give a hexadecimal key of at least 64 characters")
        exit(1)

    if not set(key).issubset(set('abcdefABCDEF0123456789')):
        print("Please for -g arg give a hexadecimal key | charset : A-F and 0-9")
        exit(1)

    return key


def parse_args():

    parser = argparse.ArgumentParser(description='ft_otp is a password generator')

    parser.add_argument('-g', help='Hexadecimal key of at least 64 characters')
    parser.add_argument('-k', help='Generates a new temporary password based on the key given as argument')

    return parser.parse_args()


def derive_key(salt):

    kdf = Argon2id(
        salt=salt,
        length=32,
        iterations=1,
        lanes=4,
        memory_cost=64 * 1024,
        ad=None,
        secret=None,
    )
    return kdf.derive(getpass.getpass("Mot de passe : ").encode("utf-8"))


def encrypt_secret(secret_hex):
    # 1) Convertir clé TOTP hex → bytes
    secret_bytes = bytes.fromhex(secret_hex)

    # 2) Générer salt et iv
    salt = os.urandom(16)
    iv = os.urandom(16)

    # 3) Dériver clé AES depuis le mot de passe
    key = derive_key(salt)

    # 4) Préparer AES-CBC
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    encryptor = cipher.encryptor()

    # 5) Padding PKCS#7
    padder = padding.PKCS7(32).padder()
    padded = padder.update(secret_bytes)
    padded += padder.finalize()

    # 6) Chiffrer
    encrypted = encryptor.update(padded) + encryptor.finalize()

    # 7) Retourner tout ce qu’il faut stocker
    return salt, iv, encrypted


def generate_keyfile(secret_hex):

    salt, iv, encrypted = encrypt_secret(secret_hex)

    data = {
        "salt": base64.b64encode(salt).decode(),
        "iv": base64.b64encode(iv).decode(),
        "data": base64.b64encode(encrypted).decode(),
    }

    with open(FILE_KEY, "w") as f:
        json.dump(data, f, indent="\t", sort_keys=True)


def main():

    args = parse_args()

    key = valid_key(args.g)

    generate_keyfile(key)


if __name__ == "__main__":
    main()
